<p>
    <h3>Step 1: Spike in the PhiX reads</h3>
</p>
<p>
    To see whether the pipeline ran correctly. The reads will be inserted in each sample, in a later step (step 25) of the pipeline there will be a concordance
    check to see if the SNPs that are put in, will be found.
</p>
<p>
    Scriptname: SpikePhiX
</p>
<p>
    Input: raw sequence file in the form of a gzipped fastq file
</p>
<p>
    Output: FastQ files (${filePrefix}_${lane}_${barcode}.fq.gz)*
</p>
   <h3> Step 2: Check the Illumina encoding</h3>
    <br/>
    In this step the encoding of the FastQ files will be checked. Older (2012 and older) sequence data contains the old Phred+64 encoding (this is called
    Illumina 1.5 encoding), new sequence data is encoded in Illumina 1.8 or 1.9 (Phred+33). If the data is 1.5, it will be converted to 1.9 encoding
<p>
    Scriptname: CheckIlluminaEncoding
    <br/>
    Input:. FastQ files (${filePrefix}_${lane}_${barcode}.fq.gz)*
</p>
<h3>
    Step 3: Calculate QC metrics on raw data
</h3>
<p>
    In this step, Fastqc, quality control (QC) metrics are calculated for the raw sequencing data. This is done using the tool FastQC. This tool will run a
    series of tests on the input file. The output is a text file containing the output data which is used to create a summary in the form of several HTML pages
    with graphs for each test. Both the text file and the HTML document provide a flag for each test: pass, warning or fail. This flag is based on criteria set
    by the makers of this tool. Warnings or even failures do not necessarily mean that there is a problem with the data, only that it is unusual compared to
    the used criteria. It is possible that the biological nature of the sample means that this particular bias is to be expected.
</p>
<p>
    Toolname: FastQC
</p>
<p>
    Scriptname: Fastqc
</p>
<p>
    Input: FastQ files (${filePrefix}_${lane}_${barcode}.fq.gz)*
</p>
<p>
    Output: ${filePrefix}.fastqc.zip archive containing amongst others the HTML document and the text file
</p>
<p>
    * filePrefix is explained in Table 4
</p>
<h3>
    Step 4: Read alignment against reference sequence
</h3>
<p>
    In this step, the Burrows-Wheeler Aligner (BWA) is used to align the (mostly paired end) sequencing data to the reference genome. The method that is used
    is BWA mem. The output is a SAM file.
</p>
<p>
    Scriptname: BwaAlign
</p>
<p>
    Input: raw sequence file in the form of a gzipped fastq file (${filePrefix}.fq.gz)
    <br/>
    Output: SAM formatted file (${filePrefix}.sam)
</p>
<p>
    Toolname: BWA
</p>
<h3>
    Step 5: Convert SAM to BAM
</h3>
<p>
    Using the Picard SamFormatConverter the SAM file generated by the previous step is converted to a compressed binary format (BAM).
</p>
<p>
    Toolname: Picard SamFormatConverter
</p>
<p>
    Scriptname: SamToBam
</p>
<p>
    Input: SAM file generated in step 4 (${filePrefix}.sam)
</p>
<p>
    Output: compressed binary (BAM) format (${filePrefix}.bam)
</p>
<h3>
    Step 6: Sort BAM and build index
</h3>
<p>
    The reads in the BAM file are sorted (coordinate based) using Sambamba sort . An index file is generated automatically, this allows for efficient random
    access to the BAM file and is used by many tools to speed up reading from a BAM file.
</p>
<p>
    Toolname: Sambamba sort
</p>
<p>
    Scriptname: SamSort
</p>
<p>
    Input: BAM file from step 5
</p>
<p>
    Output: <br />
    - Sorted BAM file (${sample}.sorted.bam) <br />
    - Index file (${sample}.sorted.bai)
</p>
<h3>
    Step 7: Merge BAMs and build index
</h3>
<p>
    To improve the coverage of sequence alignments, a sample can be sequenced on multiple lanes and/or flowcells. If this is the case for the sample(s) being
    analyzed, this step merges all BAM files of one sample and indexes this new file. If there is just one BAM file for a sample, nothing happens.
</p>
<p>
    Toolname: Sambamba merge
</p>
<p>
    Scriptname: SambambaMerge
</p>
<p>
    Input: BAM files from step 6 (${sample}.sorted.bam)
</p>
<p>
    Output: merged BAM file (${sample}.merged.bam)
</p>
<h3>
    Step 8: Mark duplicates + creating dedup metrics
</h3>
<p>
    In this step, the BAM file is examined to locate duplicate reads, using Sambamba markdup. A mapped read is considered to be duplicate if the start and end
    base of two or more reads are located at the same chromosomal position in comparison to the reference genome. For paired-end data the start and end
    locations for both ends need to be the same to be called duplicate. One read pair of these duplicates is kept, the remaining ones are flagged as being
    duplicate.
</p>
<p>
    Toolname: Sambamba markdup &amp; Sambamba flagstat
</p>
<p>
    Scriptname: MarkDuplicates
</p>
<p>
    Input: Merged BAM file from generated in step 7 (${sample}.merged.bam)
</p>
<p>
    Output:<br />
    - BAM file with duplicates flagged (${sample}.dedup.bam)<br/>
    - BAM index file (${sample}.dedup.bam.bai) <br/>
    - Dedup metrics file (${sample}.merged.dedup.metrics) <br/>
</p>
<h3>
    Step 09a: Calling big deletions with Delly
</h3>
<p>
    In this step, the progam Delly calls deletions from the merged BAM file. The deletions are written to a VCF file, along with information such as difference
    in length between REF and ALT alleles, type of structural variant end information about allele depth.
</p>
<p>
    Toolname: Delly
</p>
<p>
    Scriptname: Delly
</p>
<p>
    Input: merged BAM file from step 7 (${sample}.merged.bam)
    <br/>
    Output: indels in VCF (${sample}.delly.vcf)
    <br/>
</p>
<h3>Step 09b. Delly annotator</h3>
<p>
    There will be some annotation to the produced vcf by Delly. This step will add hpo terms and snpEff annotation
</p>
<p>
    Toolname: CmdAnnotator
</p>
<p>
    Scriptname: DellyAnnotator
</p>
<p>
    Input: indels in VCF (${sample}.delly.vcf)
</p>
<p>
    Output:<br /> 
	- ${sample}.delly.snpeff.vcf <br/>
	- ${sample}.snpeff.hpo.vcf <br/>
</p>
<h3>Step 10a: GenderCalculate</h3>
<p>
    Due to the fact a male has only one X chromosome it is important to know if the sample is male or female. Calculating the coverage on the non pseudo
    autosomal region and compare this to the average coverage on the complete genome predicts male or female well.
</p>
<p>
    Toolname: GenderCalculate
</p>
<p>
    Input: dedup BAM file (${sample}.dedup.bam)
</p>
<p>
    Output: ${dedupBam}.nonAutosomalRegionChrX_hs_metrics
</p>

    <h3>Step 10b: CramConversion</h3>
<p>
    Producing more compressed bam files, decreasing size with 40%
</p>
<p>
    Toolname: Scramble
</p>
<p>
    Input: dedup BAM file (${sample}.dedup.bam)
</p>
<p>
    Output: dedup CRAM file (${sample}.dedup.bam.cram)
</p>
<p>
    <h3>Step 11: Make md5’s for the realigned bams</h3>
</p>
<p>
    Small step to create md5sums for the realigned bams created in step 9
</p>
<p>
    Input: realigned BAM file (.realigned.bam)
</p>
<p>
    Output: md5sums (.realigned.bam.md5)
</p>
<h3>
    Step 12: SequonomConcordance Check
</h3>
<p>
    Scriptname: SequenomConcordanceCheck
</p>
<p>
    As a last measure of quality of the SNPs reported in the previous steps, the concordance between the SNPs and the SNPs called using a Sequenom of the same
    sample is checked. If at least … SNPs overlap and the concordance is around 97% or higher, the SNPs reported in the previous steps are accepted as being of
    reliable quality and exclude a potential sample swap.
</p>
<p>
    The concordance check is done in several steps (provided Sequenom report is present):
</p>
<p>
    ● sed, awk, uniq, sort, grep to convert the Sequenom report of an analyzed sample into map, lgen and fam files (plink long-format fileset)
</p>
<p>
    ● plink-1.07 recode which is used for creating a *.bed file
</p>
<p>
    ● plink 1.08 unpublished development version recode which is used to create a genotype in *.vcf format
</p>
<p>
    ● command line Perl to change the header
</p>
<p>
    ● sed and awk to convert from vcf to bed
</p>
<p>
    ● fastaFromBed from BEDTools-Version-2.11.2 to create a uscs style tab elimited fasta file from the bed file, using reference sequence build 37
</p>
<p>
    ● align-vcf-to-ref.pl from inhouse_scripts
</p>
<p>
    ● head, sed, cat to change header
</p>
<p>
    ● iChip_pos_to_interval_list.pl from inhouse_scripts is used to create an interval list of Sequenom SNPs which is used to call inhouse SNPs
</p>
<p>
    ● GATK-1.2-1-g33967a4 UnifiedGenotyper which is used for calling SNPs on all positions known to be on array and VCF and calculating the concordance between
    array SNPs and inhouse pipeline SNPs
</p>
<p>
    ● change_vcf_filter.pl from inhouse scripts is used to change the FILTER column from GATK "called SNPs". All SNPs having Q20 &amp; DP10 change to "PASS",
    all other SNPs are "filtered" (not used in concordance check)
</p>
<p>
    ● GATK-1.2-1-g33967a4 VariantEval to calculate condordance between Sequenom SNPs and GATK "called SNPs"
</p>
<p>
    ● echo to prepare the header of the output concordance file
</p>
<p>
    ● R script extract_info_GATK_variantEval_V3.R (using library from GATK-1.3-24-gc8b1c92) from inhouse scripts to format the concordance output file.
</p>
<p>
    When the Sequenom report is not present no concordance can be calculated, an empty concordance output file with a header and one row of NAs is created on
    the fly.
</p>
<p>
    Toolname: BASH programs (sed, awk, uniq, sort, grep, head, cat, echo), plink-1.07, plink 1.08, fastaFromBed (BEDTools-Version-2.11.2), align-vcf-to-ref.pl
    from inhouse_scripts, iChip_pos_to_interval_list.pl from inhouse_scripts, GATK-1.2-1-g33967a4 UnifiedGenotyper, change_vcf_filter.pl from inhouse scripts,
</p>
<p>
    GATK-1.2-1-g33967a4 VariantEval, extract_info_GATK_variantEval_V3.R (using library from GATK-1.3-24-gc8b1c92) from inhouse scripts.
</p>
<p>
    Scriptname: ConcordanceCheck
</p>
<p>
    Input: SNP file generated with a Sequenom.
</p>
<p>
    Output: concordance file (.concordance.ngsVSSequenom.txt)
</p>
<h3>Step 13: Calculate coverage per base and per target</h3>

<p> 
Calculates coverage per base and per target, the output will contain chromosomal position, coverage per base and gene annotation
</p>
<p>
    Toolname: GATK DepthOfCoverage
</p>
<p>
    Scriptname: CoverageCalculations
</p>
<p>
    Input: dedup BAM file (.merged.dedup.bam)
<p>
    Output: tab delimeted file containing chromosomal position, coverage per base and Gene annotation name (.coveragePerBase.txt)
</p>

    <h3>Step 14 (a,b,c,d): Calculate alignment QC metrics</h3>
<p>
    In this step, QC metrics are calculated for the alignment created in the previous steps. This is done using several QC related Picard tools:
</p>
<p>
    ● CollectAlignmentSummaryMetrics <br />
    ● CollectGcBiasMetrics <br />
    ● CollectInsertSizeMetrics <br />
    ● MeanQualityByCycle (machine cycle) <br />
    ● QualityScoreDistribution <br />
    ● CalculateHsMetrics (hybrid selection) <br />
    ● BamIndexStats <br />
</p>
<p>
    These metrics are later used to create tables and graphs (step 24). The Picard tools also output a PDF version of the data themselves, containing graphs.
</p>
<p>
    Toolname: several Picard QC tools
</p>
<p>
    Scriptname: Collect metrics
</p>
<p>
    Input: dedup BAM file (.merged.dedup.bam)
</p>
<p>
    Output: alignmentmetrics, gcbiasmetrics, insertsizemetrics, meanqualitybycycle, qualityscoredistribution, hsmetrics, bamindexstats (text files and matching
    PDF files)
</p>
<h3>
    Step 15: Gender check
</h3>
<p>
    Due to the fact a male has only one X chromosome it is important to know if the sample is male or female. Calculating the coverage on the non pseudo
    autosomal region and compare this to the average coverage on the complete genome predicts male or female well.
</p>
<p>
    Toolname: GenderCheck
    <br/>
    Input: ${dedupBam}.hs_metrics (step 14 &amp; ${dedupBam}.nonAutosomalRegionChrX_hs_metrics (step 10)
</p>
<p>
    Output: ${sample}.chosenSex.txt
</p>
<h3>
    Step 16a: Call variants (VariantCalling)
</h3>
<p>
    The GATK HaplotypeCaller estimates the most likely genotypes and allele frequencies in an alignment using a Bayesian likelihood model for every position of
    the genome regardless of whether a variant was detected at that site or not. This information can later be used in the project based genotyping step.
</p>
<p>
    Toolname: GATK HaplotypeCaller
</p>
<p>
    Scriptname: VariantGVCFCalling
</p>
<p>
    Input: merged BAM files
    <br/>
    Output: gVCF file (${sample}.${batchBed}.variant.calls.g.vcf)
</p>
<h3>Step 16b: Combine variants</h3>
<p>
    When there 200 or more samples the gVCF files should be combined into batches of equal size. (NB: These batches are different then the ${batchBed}.)
    The batches will be calculated and created in this step. If there are less then 200, this step will automatically be skipped.
</p>
<p>
    Toolname: GATK CombineGVCFs
</p>
<p>   
    Scriptname: VariantGVCFCombine
</p>
<p>
    Input: gVCF file (from step 16a)
</p>
<p>
    Output: Multiple combined gVCF files (${project}.${batchBed}.variant.calls.combined.g.vcf{batch}
</p>
<p>
    <h3>Step 16c: Genotype variants </h3>
</p>
<p>
    In this step there will be a joint analysis over all the samples in the project. This leads to a posterior probability of a variant allele at a site. SNPs
    and small Indels are written to a VCF file, along with information such as genotype quality, allele frequency, strand bias and read depth for that
    SNP/Indel.
</p>
<p>
    Toolname: GATK GenotypeGVCFs
</p>
<p>
    Scriptname: VariantGVCFGenotype
</p>
<p>
    Input: gVCF files from step 16a <strong>or</strong> combined gVCF files from step 16b
</p>
<p>
    Output: VCF file for all the samples in the project (${project}.${batchBed}.variant.calls.genotyped.vcf)
</p>
<h3>Step 17: Merge batches</h3>
<p>
    Running GATK CatVariants to merge all the files created in the genotype variants step (Step 16c) into one.
</p>
<p>
    Tools: GATK CatVariants
</p>
<p>
    Scriptname: MergeChrAndSplitVariants
</p>
<p>
    Input: files created in step 16 (${project}.{batchBed}.variant.calls.vcf)
</p>
<p>
    Output: merged snp and indel file (${project}.variant.calls.GATK.sorted.vcf)
    <br/>
    <br/>
</p>
    <h3>Step 18: VariantAnnotator</h3>
<p>
    An HTML file with some statistics and a text file with SNPs per gene and region are produced.
</p>
<p>
    Toolname: GATK VariantAnnotator
</p>
<p>
    Scriptname: StructuralVariantAnnotator
</p>
<p>
    Input: VCF file (.calls.vcf)
</p>
<p>
    Output: SNPeff VCF file (.annotated.vcf)
</p>

<h3>Step 19: Split indels and SNPs</h3>
<p>
    This step is necessary because the filtering of the vcf needs to be done seperately.
</p>
<p>
    Toolname: GATK SelectVariants
</p>
<p>
    Scriptname: SplitIndelsAndSNPs
</p>
<p>
    Input: VCF file (.annotated.vcf)
</p>
<p>
    Output: .annotated.indels.vcf and .annotated.snps.vcf
</p>
    <h3>Step 20: (a) SNP and (b) Indel filtration</h3>
<p>
    Based on certain quality thresholds (based on GATK best practices) the SNPs and indels are filtered, and marked as Lowqual or Pass.
</p>
<p>
    SNP filters: <br />
    - QD &lt; 2.0 <br/>
    - MQ &lt; 25.0 <br/>
    - FS &gt; 60.0 <br/>
    - MQRankSum &lt; -12.5 <br />
    - ReadPosRankSum &lt; -8.0 <br />
</p>
<p>
    Indel filters: <br />
    - QD &lt; 2.0 <br />
    - FS &gt; 200.0 <br />
    - ReadPosRankSum &lt; 20.0 <br />
</p>
<p>
    Toolname: GATK VariantFiltration
</p>
<p>
    Scriptname: VariantFiltration
</p>
<p>
    Input: <br />
	- 20a (.snpEff.annotated.snps.vcf) <br />
    	- 20b (.snpEff.annotated.indels.vcf) <br />
</p>
<p>
    Output:<br /> 
	- 20a filtered snp vcf file (.snpEff.annotated.filtered.snps.vcf) <br />
	- 20b filtered indel vcf file (.snpEff.annotated.filtered.indels.vcf)
</p>
    <h3>Step 21: Merge indels and SNPs</h3>
<p>
    Merge all the SNPs and indels into one file (per project) and merge SNPs and indels per sample.
</p>
<p>
    Toolname: GATK CombineVariants
</p>
<p>
    Scriptname: MergeIndelsAndSnps
</p>
<p>
    Input: .annotated.filtered.indels.vcf and .annotated.snps.vcf
</p>
<p>
    Output:<br /> 
	- ${sample}.final.vcf <br /> 
	- ${project}.final.vcf <br />
</p>
<h3>Step 22: Convert structural variants VCF to table </h3>
<p>
    In this step the indels in VCF format are converted into a tabular format using Perlscript vcf2tab by F. Van Dijk (see:
    GCC_P0009_Pipeline_tools_and_resources.docx).
</p>
<p>
    Toolname: vcf2tab.pl
</p>
<p>
    Scriptname: IndelVcfToTable
</p>
    Input: (${sample}.final.vcf)
</p>
<p>
    Output: (${sample}.final.vcf.table)
</p>
    <h3>Step 23: In silico concordance check</h3>
<p>
    The reads that are inserted contain SNPs that are handmade. To see whether the pipeline ran correctly at least these SNPs should be found.
</p>
<p>
    Input: InSilicoData.chrNC_001422.1.variant.calls.vcf and ${sample}.variant.calls.GATK.sorted.vcf
 </p>
<p>
    Output: inSilicoConcordance.txt
</p>
   <h3> Step 24a: Prepare QC Report, collecting metrics </h3>
<p>
    Combining all the statistics which are used in the QC report.
</p>
<p>
    Scriptname:QCStats
</p>
<p>
    Toolname: pull_DNA_Seq_Stats.py 
</p>
<p>
    Input: metrics files from steps 14a/b/c/d (*.hsmetrics, *.alignmentmetrics, *.insertsizemetrics), flagstat file and concordance file
    (*.dedup.metrics.concordance.ngsVSarray.txt)
   </p>
<p>
    Output: ${sample}.total.qc.metrics.table
</p>
<h3>Step 24b: Generate quality control report</h3>
<p>
    The step in the inhouse sequence analysis pipeline is to output the statistics and metrics from each step that produced such data that was collected in the
    QCStats step before. From these, tables and graphs are produced. Reports are then created and written to a separate quality control (QC) directory, located
    IN RunNr/Results/qc/statistics (see: SOP_0001_data_structure.txt, Figure 2). This report will be outputted in html and pdf. Converting html to pdf the tool
    wkhtmltopdf is used.
</p>
<p>
    Toolname: wkhtmltopdf
</p>
<p>
    Scriptname: QCReport
</p>
<p>
    Input: ${sample}.total.qc.metrics.table
</p>
<p>
    Output: A quality control report html(*_QCReport.html) and pdf (*_QCReport.html)
</p>
<h3>Step 25: Check if all files are finished</h3>
<p>
    This step is checking if all the steps in the pipeline are actually finished. It sometimes happens that a job is not submitted to the scheduler. If
    everything is finished than it will write a file called CountAllFinishedFiles_CORRECT, if not it will make CountAllFinishedFiles_INCORRECT. When it is not
    all finished it will show in the CountAllFinishedFiles_INCORRECT file which files are not finished yet.
</p>
<p>    
Scriptname: CountAllFinishedFiles
</p>
<p>   
Input: all .sh scripts + all .sh.finished files in the jobs folder
</p>
<p>
    Output: CountAllFinishedFiles_CORRECT or CountAllFinishedFiles_INCORRECT
</p>
<h3>Step 26: Prepare data to ship to the customer</h3>
<p>
    In this last step the final results of the inhouse sequence analysis pipeline are gathered and prepared to be shipped to the customer. The pipeline tools
    and scripts write intermediate results to a temporary directory (see: GCC_P0001_data_structure.docx). From these, a selection is copied to a results
    directory. This directory has five subdirectories:
</p>
<p>
    o alignment: the merged BAM file with index <br />
    o coverage: coverage statistics and plots <br />
    o coverage_visualization: coverage BEDfiles <br />
    o qc: all QC files, from which the QC report is made <br />
    o rawdata/ngs: symbolic links to the raw sequence files and their md5 sum <br />
    o snps: all SNP calls in VCF format and in tab-delimited format <br />
    o structural_variants: all SVs calls in VCF and in tab-delimited format <br />
    Additionally, the results directory contains the final QC report, the worksheet which was the basis for this analysis (see 4.2) and a zipped archive with
    the data that will be shipped to the client (see: GCC_P0006_Datashipment.docx). The archive is accompanied by an md5 sum and README file explaining the
    contents.
</p>
<p>
    Scriptname: CopyToResultsDir
</p>
